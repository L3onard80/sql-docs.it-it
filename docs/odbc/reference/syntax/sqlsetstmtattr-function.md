---
title: Funzione SQLSetStmtAttr | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 583639a5cd4680bf6cfcf03bbaf6ee9eb63adba8
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/15/2019
ms.locfileid: "68039652"
---
# <a name="sqlsetstmtattr-function"></a>Funzione SQLSetStmtAttr
**Conformità**  
 Versione introdotta: Conformità agli standard 3.0 di ODBC: ISO 92  
  
 **Riepilogo**  
 **SQLSetStmtAttr** imposta gli attributi correlati a un'istruzione.  
  
> [!NOTE]
>  Per altre informazioni su cosa the Driver Manager esegue il mapping a questa funzione quando un'applicazione ODBC *3.x* applicazione funziona con un database ODBC *2.x* driver, vedere [Mapping di funzioni di sostituzione per Aut Compatibilità delle applicazioni](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Sintassi  
  
```cpp  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Argomenti  
 *StatementHandle*  
 [Input] Handle di istruzione.  
  
 *Attribute*  
 [Input] Opzione da impostare, elencato in "Commenti".  
  
 *ValuePtr*  
 [Input] Valore da associare *attributo*. A seconda del valore di *attributo*, *ValuePtr* sarà uno dei seguenti:  
  
-   Handle descrittore di ODBC.  
  
-   Valore SQLUINTEGER.  
  
-   Valore SQLULEN.  
  
-   Un puntatore a uno dei seguenti:  
  
    -   Una stringa di caratteri con terminazione null.  
  
    -   Un buffer binario.  
  
    -   Un valore o una matrice di tipo SQLLEN, SQLULEN o SQLUSMALLINT.  
  
    -   Un valore definito dal driver.  
  
 Se il *attributo* l'argomento è un valore, specifici del driver *ValuePtr* potrebbe essere un intero con segno.  
  
 *StringLength*  
 [Input] Se *attributo* è un attributo definito da ODBC e *ValuePtr* punta a una stringa di caratteri o un buffer binario, la lunghezza di questo argomento deve essere \* *ValuePtr*. Se *attributo* è un attributo definito da ODBC e *ValuePtr* è un intero *StringLength* viene ignorato.  
  
 Se *attributo* è un attributo definito dal driver, l'applicazione indica la natura dell'attributo da Gestione Driver impostando il *StringLength* argomento. *StringLength* può avere i valori seguenti:  
  
-   Se *ValuePtr* è un puntatore a una stringa di caratteri, quindi *StringLength* è la lunghezza della stringa o SQL_NTS.  
  
-   Se *ValuePtr* è un puntatore a un buffer binario, quindi l'applicazione inserisce il risultato del SQL_LEN_BINARY_ATTR (*lunghezza*) (macro) in *StringLength*. Un valore negativo in questo modo vengono inserite *StringLength*.  
  
-   Se *ValuePtr* è un puntatore a un valore diverso da una stringa di caratteri o stringa binaria, quindi *StringLength* deve avere il valore SQL_IS_POINTER.  
  
-   Se *ValuePtr* contiene un valore di lunghezza fissa, quindi *StringLength* è SQL_IS_INTEGER o SQL_IS_UINTEGER, come appropriato.  
  
## <a name="returns"></a>Valori di codice restituiti  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR o SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnostica  
 Quando **SQLSetStmtAttr** restituisce SQL_ERROR o SQL_SUCCESS_WITH_INFO, un valore SQLSTATE associato possono essere ottenuti chiamando **SQLGetDiagRec** con un *HandleType* di SQL _HANDLE_STMT e un *gestiscono* dei *StatementHandle*. Nella tabella seguente sono elencati i valori SQLSTATE comunemente restituiti da **SQLSetStmtAttr** e illustra ognuna nel contesto di questa funzione; la notazione "(DM)" precede le descrizioni di SQLSTATE restituiti da Gestione Driver. Il codice restituito a ogni valore SQLSTATE è SQL_ERROR, se non specificato diversamente.  
  
|SQLSTATE|Errore|Descrizione|  
|--------------|-----------|-----------------|  
|01000|Avviso generale|Messaggio informativo specifico del driver. (Funzione restituisce SQL_SUCCESS_WITH_INFO).|  
|01S02|Valore di opzione modificato|Il driver non supportava il valore specificato nel *ValuePtr*, o il valore specificato in *ValuePtr* non è valido a causa di condizioni di lavoro di implementazione, in modo che il driver sostituito un valore simile. (**SQLGetStmtAttr** può essere chiamato per determinare il valore di sostituzione temporaneamente.) Il valore di sostituzione è valido per il *StatementHandle* fino a quando il cursore è chiuso, a quel punto l'attributo dell'istruzione viene ripristinato il valore precedente. Gli attributi di istruzione che è possibile modificare sono:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT  SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (Funzione restituisce SQL_SUCCESS_WITH_INFO).|  
|08S01|Errore del collegamento di comunicazione|Il collegamento di comunicazione tra il driver e l'origine dati a cui è stato connesso il driver non è stato possibile prima dell'elaborazione di funzione è stata completata.|  
|24000|Stato del cursore non valido|Il *attributo* era SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_SIMULATE_CURSOR o SQL_ATTR_USE_BOOKMARKS e il cursore è stato aperto.|  
|HY000|Errore generale|Si è verificato un errore per cui si è verificato alcun errore SQLSTATE specifico e per cui è stato definito alcun SQLSTATE specifici dell'implementazione. Il messaggio di errore restituito da **SQLGetDiagRec** nel  *\*MessageText* buffer viene descritto l'errore e la relativa causa.|  
|HY001|Errore di allocazione della memoria|Il driver è stato in grado di allocare la memoria necessaria per supportare l'esecuzione o il completamento della funzione.|  
|HY009|Utilizzo non valido del puntatore null|Il *attributo* argomento identificato un attributo di istruzione che un attributo di stringa, obbligatorio e il *ValuePtr* argomento era un puntatore null.|  
|HY010|Errore nella sequenza della funzione|(DM) a cui è stata chiamata per l'handle di connessione che è associata una funzione in modo asincrono in esecuzione la *StatementHandle*. Questa funzione asincrona era ancora in esecuzione quando il **SQLSetStmtAttr** funzione è stata chiamata.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, o **SQLMoreResults** è stato chiamato per il *StatementHandle* e restituito SQL_PARAM_DATA_ È DISPONIBILE. Questa funzione è stata chiamata prima per tutti i parametri trasmessi sono stati recuperati i dati.<br /><br /> (DM) a cui è stata chiamata per una funzione in modo asincrono in esecuzione la *StatementHandle* ed era ancora in esecuzione quando è stata chiamata questa funzione.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, oppure **SQLSetPos** è stato chiamato per il  *StatementHandle* e restituito SQL_NEED_DATA. Questa funzione è stata chiamata prima dei dati è stati inviati per tutti i parametri data-at-execution o più colonne.|  
|HY011|Impossibile impostare l'attributo adesso|Il *attributo* era SQL_ATTR_CONCURRENCY, ATTR_CURSOR_TYPE SQL _, ATTR_SIMULATE_CURSOR SQL _ o ATTR_USE_BOOKMARKS SQL _ e l'istruzione è stata preparata.|  
|HY013|Errore di gestione della memoria|La chiamata di funzione non è stato possibile elaborare perché gli oggetti di memoria sottostante non sono accessibile, probabilmente a causa di condizioni di memoria insufficiente.|  
|HY017|Utilizzo non valido di un handle di descrittore allocato automaticamente|(DM) di *attributo* argomento era SQL_ATTR_IMP_ROW_DESC o SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) di *attributo* argomento era SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC e il valore nella *ValuePtr* originariamente un handle di descrittore allocato in modo implicito diverse da handle per il ARD o APD allocato.|  
|HY024|Valore dell'attributo non valido|Dato l'oggetto specificato *attributo* valore, in cui è stato specificato un valore non valido *ValuePtr*. (The Driver Manager restituisce il valore SQLSTATE solo per la connessione e gli attributi di istruzione che accettano un set discreto di valori, ad esempio SQL_ATTR_ACCESS_MODE o ATTR_ASYNC_ENABLE SQL _. Per tutti gli altri connessione e gli attributi di istruzione, il driver deve verificare il valore specificato nel *ValuePtr*.)<br /><br /> Il *attributo* argomento era SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC, e *ValuePtr* era un handle di descrittore allocato in modo esplicito che non appartiene alla stessa connessione di  *StatementHandle* argomento.|  
|HY090|Lunghezza della stringa o buffer non valido|(DM)  *\*ValuePtr* è una stringa di caratteri e il *StringLength* argomento era minore di 0 ma non era SQL_NTS.|  
|HY092|Identificatore di attributo/opzione non è valido|(DM) il valore specificato per l'argomento *attributo* non è valido per la versione di ODBC supportati dal driver.<br /><br /> (DM) il valore specificato per l'argomento *attributo* era un attributo di sola lettura.|  
|HY117|Connessione viene sospesa a causa dello stato di transazione sconosciuto. Solo disconnettere e le funzioni di sola lettura sono consentite.|(DM) per altre informazioni sullo stato sospeso, vedere [SQLEndTran-funzione](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Funzionalità opzionale non implementata|Il valore specificato per l'argomento *attributo* era un attributo di istruzione ODBC valido per la versione di ODBC supportati dal driver, ma non era supportata dal driver.<br /><br /> Il *attributo* argomento era SQL_ATTR_ASYNC_ENABLE e una chiamata a **SQLGetInfo** con un *InfoType* di SQL_ASYNC_MODE restituisce SQL_AM_CONNECTION.<br /><br /> Il *attributo* argomento era SQL_ATTR_ENABLE_AUTO_IPD e il valore dell'attributo di connessione SQL_ATTR_AUTO_IPD SQL_FALSE.|  
|HYT01|Timeout di connessione scaduto|Il periodo di timeout di connessione è scaduto prima che l'origine dati ha risposto alla richiesta. Il periodo di timeout di connessione viene impostato tramite **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Driver non supporta questa funzione|Il driver (DM) associato il *StatementHandle* non supporta la funzione.|  
|S1118|Driver non supporta la notifica asincrona|Se il chiamante **SQLSetStmtAttr** SQL_ATTR_ASYNC_STMT_EVENT; impostare la notifica asincrona non è supportata dal driver.|  
  
## <a name="comments"></a>Commenti  
 Gli attributi di istruzione per un'istruzione rimangono valide fino a quando non sono state modificate da un'altra chiamata a **SQLSetStmtAttr** o fino a quando l'istruzione viene eliminata chiamando **SQLFreeHandle**. La chiamata **SQLFreeStmt** con SQL_CLOSE, SQL_UNBIND oppure SQL_RESET_PARAMS opzione non consente di ripristinare gli attributi di istruzione.  
  
 Alcuni attributi di istruzione supportano la sostituzione di un valore simile se l'origine dati non supporta il valore specificato nel *ValuePtr*. In questi casi, il driver restituisce SQL_SUCCESS_WITH_INFO e SQLSTATE 01S02 (valore dell'opzione modificato). Ad esempio, se *attributo* è SQL_ATTR_CONCURRENCY e *ValuePtr* è SQL_CONCUR_ROWVER, e se l'origine dati non supporta questo, il driver sostituisce SQL_CONCUR_VALUES e restituisce SQL _ SUCCESS_WITH_INFO. Per determinare il valore di sostituzione, un'applicazione chiama **SQLGetStmtAttr**.  
  
 Imposta il formato delle informazioni con *ValuePtr* dipende specificato *attributo*. **SQLSetStmtAttr** accetta le informazioni sugli attributi in uno dei due formati: stringa di caratteri o un valore intero. Il formato della ognuno viene indicato nella descrizione dell'attributo. Si applica questo formato per le informazioni restituite per ogni attributo nella **SQLGetStmtAttr**. Carattere stringhe a cui fa riferimento il *ValuePtr* argomento di **SQLSetStmtAttr** avere una lunghezza di *StringLength*.  
  
> [!NOTE]
>  La possibilità di impostare gli attributi di istruzione a livello di connessione chiamando **SQLSetConnectAttr** è stata deprecata in ODBC *3.x*. ODBC *3.x* applicazioni non devono mai impostato gli attributi di istruzione a livello di connessione. ODBC *3.x* gli attributi di istruzione non possono essere impostati a livello di connessione, fatta eccezione per gli attributi SQL_ATTR_METADATA_ID e SQL_ATTR_ASYNC_ENABLE, che sono entrambi gli attributi di connessione e gli attributi di istruzione e può essere impostare a livello di connessione o il livello di istruzione.  
> 
> [!NOTE]
>  ODBC *3.x* i driver necessitano supportano questa funzionalità solo se funzionano con ODBC *2.x* applicazioni che impostano ODBC *2.x* opzioni dell'istruzione a livello di connessione. Per altre informazioni, vedere "Impostazione di opzioni in the connessione livello di istruzione" nella sezione [Mapping di SQLSetConnectOption](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) nell'appendice g: Driver linee guida per la compatibilità con le versioni precedenti.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Attributi di istruzione che imposta i campi di descrizione  
 Numero di attributi di istruzione corrisponde a un campo di intestazione di un descrittore. Impostando questi attributi effettivamente i risultati nell'impostazione dei campi del descrittore. Impostazione dei campi da una chiamata a **SQLSetStmtAttr** piuttosto che a **SQLSetDescField** ha il vantaggio che un handle di descrittore non deve essere ottenuto per la chiamata di funzione.  
  
> [!CAUTION]  
>  La chiamata **SQLSetStmtAttr** per un'unica istruzione può influire sulle altre istruzioni. Ciò si verifica quando il APD o ARD associate all'istruzione viene allocato in modo esplicito ed è anche associato con le altre istruzioni. In quanto **SQLSetStmtAttr** modifica il APD o ARD, le modifiche si applicano a tutte le istruzioni a cui è associato questo descrittore. Se questo non è il comportamento richiesto, l'applicazione deve annullare l'associazione da altre istruzioni questo descrittore (chiamando **SQLSetStmtAttr** per impostare il campo SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC a un altro handle descrittore) prima di chiamare **SQLSetStmtAttr** nuovamente.  
  
 Quando un campo di descrizione è impostato come risultato l'attributo di istruzione corrispondente viene impostato, il campo viene impostato solo per i descrittori applicabili che sono attualmente associati con l'istruzione identificato dal *StatementHandle* argomento e l'impostazione di attributo non influiscono su eventuali descrittori che possono essere associati a tale istruzione in futuro. Quando un campo di descrizione che è anche un attributo dell'istruzione è impostato da una chiamata a **SQLSetDescField**, viene impostato l'attributo di istruzione corrispondente. Se viene annullato l'associazione di un descrittore allocato in modo esplicito da un'istruzione, un attributo di istruzione che corrisponde a un campo di intestazione verrà ripristinato il valore del campo nel descrittore di allocati in modo implicito.  
  
 Quando viene allocata un'istruzione (vedere [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), quattro handle descrittore automaticamente allocati e associati all'istruzione. Gli handle di descrittore allocato in modo esplicito possono essere associati con l'istruzione chiamando **SQLAllocHandle** con un *fHandleType* di SQL_HANDLE_DESC per allocare un handle descrittore e quindi chiamando  **SQLSetStmtAttr** per associare l'handle descrittore con l'istruzione.  
  
 Gli attributi di istruzione nella tabella riportata di seguito corrispondono ai campi di intestazione di descrizione.  
  
|attributo di istruzione|Campo di intestazione|DESC.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|ARD|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|ARD|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|ARD|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|ARD|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Attributi di istruzione  
 Gli attributi attualmente definiti e la versione di ODBC in cui sono state introdotte vengono visualizzati nella tabella seguente. è previsto che verranno definiti altri attributi da tutti i driver per sfruttare i vantaggi di origini dati diverse. Un intervallo di attributi è riservato da ODBC. gli sviluppatori di driver necessario riservare i valori per il proprio uso specifici del driver da Open Group. Per altre informazioni, vedere [tipi di dati specifici del Driver, tipi di descrittori, tipi di informazioni, tipi di diagnostica e gli attributi](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|attribute|*ValuePtr* contenuto|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|L'handle per le chiamate successive a APD **SQLExecute** e **SQLExecDirect** dell'handle di istruzione. Il valore iniziale di questo attributo è il descrittore allocato in modo implicito quando l'istruzione è stata inizialmente allocato. Se il valore di questo attributo è impostato su SQL_NULL_DESC o l'handle allocato in origine per il descrittore, da quest'ultimo verrà dissociato handle APD allocato in modo esplicito che era precedentemente associato l'handle di istruzione e l'handle di istruzione Ripristina il in modo implicito allocato handle APD.<br /><br /> Questo attributo non può essere impostato su un handle di descrittore allocato in modo implicito per un'altra istruzione o a un altro handle descrittore che è stato impostato in modo implicito nella stessa istruzione. gli handle di descrittore allocato in modo implicito non possono essere associati più di un'istruzione o handle descrittore.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|Handle per il ARD per recuperi successivi nell'handle di istruzione. Il valore iniziale di questo attributo è il descrittore allocato in modo implicito quando l'istruzione è stata inizialmente allocato. Se il valore di questo attributo è impostato su SQL_NULL_DESC o l'handle allocato in origine per il descrittore, da quest'ultimo verrà dissociato handle ARD allocato in modo esplicito che era precedentemente associato l'handle di istruzione e l'handle di istruzione Ripristina il in modo implicito allocato handle ARD.<br /><br /> Questo attributo non può essere impostato su un handle di descrittore allocato in modo implicito per un'altra istruzione o a un altro handle descrittore che è stato impostato in modo implicito nella stessa istruzione. gli handle di descrittore allocato in modo implicito non possono essere associati più di un'istruzione o handle descrittore.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1.0)|Un valore SQLULEN che specifica se una funzione chiamata con l'istruzione specificata viene eseguita in modo asincrono:<br /><br /> SQL_ASYNC_ENABLE_OFF = supporto a livello di esecuzione asincrona dell'istruzione Disable (predefinito).<br /><br /> SQL_ASYNC_ENABLE_ON = supporto a livello di esecuzione asincrona dell'istruzione attiva.<br /><br /> Per altre informazioni, vedere [esecuzione asincrona (metodo di Polling)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Per i driver con supporto per l'esecuzione asincrona a livello di istruzione, l'attributo di istruzione SQL_ATTR_ASYNC_ENABLE è di sola lettura. Il valore è identico al valore dell'attributo a livello di connessione con lo stesso nome al momento che è stato allocato l'handle di istruzione.<br /><br /> La chiamata **SQLSetStmtAttr** per impostare SQL_ATTR_ASYNC_ENABLE quando il SQL_ASYNC_MODE *InfoType* restituisce SQL_AM_CONNECTION restituisce SQLSTATE HYC00 (funzionalità facoltativa non implementata). Per altre informazioni, vedere [funzione SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) per altre informazioni.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|SQLPOINTER un valore che rappresenta un handle di evento.<br /><br /> Notifica del completamento delle funzioni asincrone è abilitata chiamando **SQLSetStmtAttr** per impostare le **SQL_ATTR_ASYNC_STMT_EVENT** attributo e specificare l'handle dell'evento.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|SQLPOINTER alla funzione di callback asincrono.<br /><br /> Solo in Gestione Driver possono chiamare patente **SQLSetStmtAttr** funzione con questo attributo.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|Un SQLPOINTER alla struttura scelta<br /><br /> Solo in Gestione Driver possono chiamare patente **SQLSetStmtAttr** funzione con questo attributo.|  
|SQL_ATTR_CONCURRENCY (ODBC 2.0)|Un valore SQLULEN che specifica la concorrenza dei cursori:<br /><br /> SQL_CONCUR_READ_ONLY = cursore è di sola lettura. Non sono consentiti aggiornamenti.<br /><br /> SQL_CONCUR_LOCK = cursore utilizza il livello più basso di blocco sufficienti a garantire che la riga può essere aggiornata.<br /><br /> SQL_CONCUR_ROWVER = cursore utilizza il controllo della concorrenza, confronto tra le versioni di riga, ad esempio SQLBase ROWID o Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = cursore utilizza il controllo della concorrenza, confronto di valori.<br /><br /> Il valore predefinito per SQL_ATTR_CONCURRENCY è SQL_CONCUR_READ_ONLY.<br /><br /> Questo attributo non può essere specificato per un cursore aperto. Per altre informazioni, vedere [tipi di concorrenza](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Se il SQL_ATTR_CURSOR_TYPE *attributo* viene modificato in un tipo che non supporta il valore corrente di SQL_ATTR_CONCURRENCY, il valore di SQL_ATTR_CONCURRENCY verrà modificato in fase di esecuzione e visualizzato quando un avviso **SQLExecDirect** oppure **SQLPrepare** viene chiamato.<br /><br /> Se il driver supporta le **SELECT FOR UPDATE** e tali un'istruzione viene eseguita anche se è impostato il valore di SQL_ATTR_CONCURRENCY su SQL_CONCUR_READ_ONLY, verrà restituito un errore. Se viene modificato il valore di SQL_ATTR_CONCURRENCY su un valore supportate dal driver per un valore di SQL_ATTR_CURSOR_TYPE ma non per il valore corrente di SQL_ATTR_CURSOR_TYPE, il valore di SQL_ATTR_CURSOR_TYPE verrà modificato in fase di esecuzione e 01S02 valore SQLSTATE (Valore dell'opzione modificate) viene generato quando **SQLExecDirect** oppure **SQLPrepare** viene chiamato.<br /><br /> Se la concorrenza specificata non è supportata dall'origine dati, il driver sostituisce una concorrenza diversa e restituisce SQLSTATE 01S02 (valore dell'opzione modificato). Per SQL_CONCUR_VALUES, il driver sostituisce SQL_CONCUR_ROWVER e viceversa. Per SQL_CONCUR_LOCK, il driver sostituisce, in ordine, SQL_CONCUR_VALUES o SQL_CONCUR_ROWVER. La validità del valore sostituito non viene verificata fino alla fase di esecuzione.<br /><br /> Per altre informazioni sulla relazione tra SQL_ATTR_CONCURRENCY e gli altri attributi del cursore, vedere [caratteristiche del cursore e il tipo di cursore](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|Un valore SQLULEN che specifica il livello di supporto necessari all'applicazione. Se si imposta questo attributo influisce su chiamate successive a **SQLExecDirect** e **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = Scrollable cursori non sono richieste per l'handle di istruzione. Se l'applicazione chiama **SQLFetchScroll** su questo handle, l'unico valore valido del *FetchOrientation* è SQL_FETCH_NEXT. Questa è l'impostazione predefinita.<br /><br /> SQL_SCROLLABLE = Scrollable i cursori sono necessarie per l'handle di istruzione. Quando si chiama **SQLFetchScroll**, l'applicazione può specificare qualsiasi valore valido del *FetchOrientation*, ottenere il posizionamento del cursore in modalità diverse dalla modalità sequenza.<br /><br /> Per altre informazioni sui cursori scorrevoli, vedere [cursori scorrevoli](../../../odbc/reference/develop-app/scrollable-cursors.md). Per altre informazioni sulla relazione tra SQL_ATTR_CURSOR_SCROLLABLE e gli altri attributi del cursore, vedere [delle caratteristiche del cursore e il tipo di cursore](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|Un valore SQLULEN che specifica se i cursori dell'handle di istruzione di rendere visibili le modifiche apportate a un risultato impostato da un altro cursore. Se si imposta questo attributo influisce su chiamate successive a **SQLExecDirect** e **SQLExecute**. Un'applicazione può leggere il valore di questo attributo per ottenere lo stato iniziale o il relativo stato come più recente impostato dall'applicazione.<br /><br /> SQL_UNSPECIFIED = non è specificato il tipo di cursore e indica se i cursori dell'handle di istruzione di rendere visibili le modifiche apportate a un set di risultati, un altro cursore. I cursori dell'handle di istruzione potrebbero rendere visibile nessuno, alcuni o tutti tali modifiche. Questa è l'impostazione predefinita.<br /><br /> SQL_INSENSITIVE = tutti i cursori di handle di istruzione Mostra il set di risultati senza che riflette le modifiche apportate a essa da qualsiasi altro tipo di cursore. I cursori INSENSITIVE sono di sola lettura. Ciò corrisponde a un cursore statico, che ha una concorrenza che è di sola lettura.<br /><br /> SQL_SENSITIVE = tutti i cursori dell'istruzione handle assicurarsi visibile tutte le modifiche apportate a un risultato impostate da un altro cursore.<br /><br /> Per altre informazioni sulla relazione tra SQL_ATTR_CURSOR_SENSITIVITY e gli altri attributi del cursore, vedere [caratteristiche del cursore e il tipo di cursore](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2.0)|Un valore SQLULEN che specifica il tipo di cursore:<br /><br /> SQL_CURSOR_FORWARD_ONLY = il cursore solo scorre verso il rollforward.<br /><br /> SQL_CURSOR_STATIC = i dati nel risultato del set è statico.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = Salva i driver e Usa le chiavi per il numero di righe specificato nell'attributo SQL_ATTR_KEYSET_SIZE istruzione.<br /><br /> SQL_CURSOR_DYNAMIC = Salva i driver e utilizza solo le chiavi per le righe nel set di righe.<br /><br /> Il valore predefinito è SQL_CURSOR_FORWARD_ONLY. Questo attributo non può essere specificato dopo l'istruzione SQL preparata.<br /><br /> Se il tipo di cursore specificato non è supportato dall'origine dati, il driver sostituisce un tipo di cursore diverso e restituisce SQLSTATE 01S02 (valore dell'opzione modificato). Con cursori dinamici o mista, il driver sostituisce, in ordine, un cursore keyset o statico. Per un cursore gestito da keyset, il driver sostituisce un cursore statico.<br /><br /> Per altre informazioni sui tipi di cursore scorrevole, vedere [tipi di cursore scorrevoli](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Per altre informazioni sulla relazione tra SQL_ATTR_CURSOR_TYPE e gli altri attributi del cursore, vedere [caratteristiche del cursore e il tipo di cursore](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|Un valore SQLULEN che specifica se viene eseguito il popolamento automatico dell'IPD:<br /><br /> SQL_TRUE = Turns sul popolamento automatico dell'IPD dopo una chiamata a **SQLPrepare**. SQL_FALSE = consente di disattivare il popolamento automatico dell'IPD dopo una chiamata a **SQLPrepare**. (Un'applicazione può comunque ottenere informazioni sui campi IPD chiamando **SQLDescribeParam**, se supportata.) Il valore predefinito dell'attributo di istruzione SQL_ATTR_ENABLE_AUTO_IPD è SQL_FALSE. Per altre informazioni, vedere [popolamento automatico dell'IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|Un SQLLEN \* che punta a un valore binario segnalibro. Quando **SQLFetchScroll** viene chiamato con *fFetchOrientation* uguale a SQL_FETCH_BOOKMARK, il driver preleva il valore di segnalibro da questo campo. Questo campo per impostazione predefinita un puntatore null. Per altre informazioni, vedere [scorrimento in base al segnalibro](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> Il valore a cui punta questo campo non viene utilizzato per l'eliminazione tramite segnalibro, aggiornare tramite segnalibro o recuperare dalle operazioni di segnalibro nel **SQLBulkOperations**, che usano i segnalibri memorizzati nella cache nei buffer di righe.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|Handle IPD. Il valore di questo attributo è il descrittore allocato quando l'istruzione è stata inizialmente allocato. L'applicazione non è possibile impostare questo attributo.<br /><br /> Questo attributo può essere recuperato da una chiamata a **SQLGetStmtAttr** ma non è stato impostato da una chiamata a **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|Handle per l'implementazione. Il valore di questo attributo è il descrittore allocato quando l'istruzione è stata inizialmente allocato. L'applicazione non è possibile impostare questo attributo.<br /><br /> Questo attributo può essere recuperato da una chiamata a **SQLGetStmtAttr** ma non è stato impostato da una chiamata a **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2.0)|Un SQLULEN che specifica il numero di righe nel keyset di un cursore gestito da keyset. Se la dimensione del keyset è 0 (impostazione predefinita), il cursore è completamente gestito da keyset. Se la dimensione del keyset è maggiore di 0, il cursore è misto (gestito da keyset all'interno del keyset e dinamici di fuori di keyset). La dimensione del keyset predefinito è 0. Per altre informazioni sui cursori gestito da keyset, vedere [cursori gestiti da keyset](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Se le dimensioni specificate superano la dimensione del keyset massimo, il driver sostituisce tali dimensioni e restituisce SQLSTATE 01S02 (valore dell'opzione modificato).<br /><br /> **SQLFetch** oppure **SQLFetchScroll** restituisce un errore se la dimensione del keyset è maggiore di 0 e minore della dimensione del set di righe.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1.0)|Un valore SQLULEN che specifica la quantità massima di dati che il driver restituisce da un carattere o una colonna di dati binari. Se *ValuePtr* è minore della lunghezza dei dati disponibili **SQLFetch** oppure **SQLGetData** tronca i dati e restituisce SQL_SUCCESS. Se *ValuePtr* è 0 (impostazione predefinita), il driver tenta di restituire tutti i dati disponibili.<br /><br /> Se la lunghezza specificata è inferiore rispetto alla quantità minima di dati che può restituire l'origine dati o maggiore rispetto alla quantità massima di dati che può restituire l'origine dati, la sostituzione driver che è il valore e restituisce SQLSTATE 01S02 (valore dell'opzione modificato).<br /><br /> Il valore di questo attributo può essere impostato su un cursore aperto. Tuttavia, l'impostazione potrebbe non aver effetto immediato, nel qual caso il driver restituirà 01S02 valore SQLSTATE (valore dell'opzione modificato) e reimpostare l'attributo il valore originale.<br /><br /> Questo attributo è progettato per ridurre il traffico di rete e deve essere supportato solo quando l'origine dati (anziché il driver) in un driver a più livelli può implementarla. Questo meccanismo non deve essere utilizzato da applicazioni per troncare i dati; per troncare i dati ricevuti, un'applicazione deve specificare la lunghezza massima del buffer nel *BufferLength* nell'argomento **SQLBindCol** oppure **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1.0)|Un valore SQLULEN corrispondente al numero massimo di righe da restituire all'applicazione per un **seleziona** istruzione. Se \* *ValuePtr* è uguale a 0 (impostazione predefinita), il driver restituisce tutte le righe.<br /><br /> Questo attributo è progettato per ridurre il traffico di rete. Concettualmente, viene applicato quando il set di risultati viene creato e limita il set di risultati al primo *ValuePtr* righe. Se il numero di righe nel set di risultati è maggiore *ValuePtr*, il set di risultati viene troncato.<br /><br /> SQL_ATTR_MAX_ROWS si applica a tutti i set di risultati sul *istruzione*, inclusi quelli restituiti dalle funzioni di catalogo. SQL_ATTR_MAX_ROWS stabilisce un limite massimo per il valore di conteggio delle righe del cursore.<br /><br /> Un driver non deve emulare il comportamento SQL_ATTR_MAX_ROWS per **SQLFetch** oppure **SQLFetchScroll** (se limitazioni delle dimensioni dei set di risultati non è possibile implementare nell'origine dati) se non è possibile garantire che sql_attr MAX_ROWS verrà implementato correttamente.<br /><br /> È definito dal driver fatto SQL_ATTR_MAX_ROWS applicato alle istruzioni diverse da istruzioni SELECT (ad esempio funzioni di catalogo).<br /><br /> Il valore di questo attributo può essere impostato su un cursore aperto. Tuttavia, l'impostazione potrebbe non aver effetto immediato, nel qual caso il driver restituirà 01S02 valore SQLSTATE (valore dell'opzione modificato) e reimpostare l'attributo il valore originale.|  
|SQL_ATTR_METADATA_ID (ODBC 3.0)|Un valore SQLULEN che determina come vengono trattati gli argomenti stringa di funzioni di catalogo.<br /><br /> Se SQL_TRUE, l'argomento della stringa di funzioni di catalogo sono trattate come identificatori. Nel caso non è significativo. Per le stringhe non delimitate, il driver rimuove spazi iniziali o finali e la stringa è stata ridotta in lettere maiuscole. Per le stringhe delimitato da virgole, il driver rimuove gli spazi iniziali o finali e accetta qualsiasi cosa ci sia racchiuso tra i delimitatori letteralmente. Se uno di questi argomenti è impostato su un puntatore null, la funzione restituisce SQL_ERROR e SQLSTATE HY009 (utilizzo non valido del puntatore null).<br /><br /> Se SQL_FALSE, gli argomenti stringa di funzioni di catalogo non sono trattate come identificatori. Il caso è significativo. Essi possono contenere un criterio di ricerca di stringa o non, a seconda dell'argomento.<br /><br /> Il valore predefinito è SQL_FALSE.<br /><br /> Il *TableType* argomenti del **SQLTables**, che accetta un elenco di valori, non è interessato da questo attributo.<br /><br /> SQL_ATTR_METADATA_ID può anche essere impostati a livello di connessione. (E SQL_ATTR_ASYNC_ENABLE sono gli attributi di istruzione che sono anche gli attributi di connessione).<br /><br /> Per altre informazioni, vedere [argomenti nelle funzioni di catalogo](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1.0)|Un valore SQLULEN che indica se il driver deve eseguire l'analisi stringhe SQL per le sequenze di escape:<br /><br /> SQL_NOSCAN_OFF = il driver analizza le stringhe SQL per le sequenze di escape (predefinito).<br /><br /> SQL_NOSCAN_ON = il driver non esegue la scansione stringhe SQL per le sequenze di escape. Al contrario, il driver invia l'istruzione direttamente all'origine dati.<br /><br /> Per altre informazioni, vedere [sequenze di Escape in ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|Un SQLULEN * valore cui fa riferimento a un offset aggiunto ai puntatori a modificare l'associazione di parametri dinamici. Se questo campo è diverso da null, il driver Dereferenzia il puntatore del mouse, aggiunge il valore dereferenziato a ognuno dei campi posticipati nel record del descrittore (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR) e utilizza i nuovi valori di puntatore durante l'associazione. È impostato su null per impostazione predefinita.<br /><br /> L'offset di associazione viene sempre aggiunto direttamente ai campi SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR. Se l'offset viene modificato in un valore diverso, il nuovo valore viene ancora aggiunto direttamente al valore nel campo del descrittore. Nuovo offset non viene aggiunto al valore del campo più alcun offset precedenti.<br /><br /> Per altre informazioni, vedere [parametro di associazione viene eseguito l'offset](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> Se si imposta questo attributo di istruzione imposta il campo SQL_DESC_BIND_OFFSET_PTR nell'intestazione APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|Un valore SQLULEN che indica l'orientamento di associazione da utilizzare per i parametri dinamici.<br /><br /> Questo campo è impostato su SQL_PARAM_BIND_BY_COLUMN (predefinito) per selezionare l'associazione per colonna.<br /><br /> Per selezionare l'associazione per riga, questo campo è impostato sulla lunghezza della struttura o un'istanza di un buffer che verrà associato a un set di parametri dinamici. Questa lunghezza deve includere lo spazio per tutti i parametri associati e di eventuali spaziature interne della struttura o del buffer per garantire che quando l'indirizzo di un parametro associato viene incrementato con la lunghezza specificata, il risultato punterà all'inizio del parametro stesso nel successivo set di parametri. Quando si usa la *sizeof* operatore in ANSI C, questo comportamento è garantito.<br /><br /> Per altre informazioni, vedere [associazione di matrici di parametri](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> Se si imposta questo attributo di istruzione imposta il campo SQL_DESC_ BIND_TYPE nell'intestazione APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valore punta a una matrice di valori SQLUSMALLINT utilizzato per ignorare un parametro durante l'esecuzione di un'istruzione SQL. Ogni valore è impostato su SQL_PARAM_PROCEED (per il parametro deve essere eseguito) o SQL_PARAM_IGNORE (per il parametro verrà ignorato).<br /><br /> Un set di parametri può essere ignorato durante l'elaborazione impostando il valore di stato nella matrice a cui punta SQL_DESC_ARRAY_STATUS_PTR in APD a SQL_PARAM_IGNORE. Se il valore di stato è impostato su SQL_PARAM_PROCEED o se nessun elemento nella matrice è impostato, viene elaborato un set di parametri.<br /><br /> Questo attributo istruzione può essere impostato su un puntatore null, nel quale caso il driver non restituisce parametri valori di stato. Questo attributo può essere impostato in qualsiasi momento, ma il nuovo valore non viene usato fino alla prossima **SQLExecDirect** oppure **SQLExecute** viene chiamato.<br /><br /> Questo attributo viene ignorato quando nessun parametro di associazione.<br /><br /> Per altre informazioni, vedere [utilizzando le matrici di parametri](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Se si imposta questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_STATUS_PTR nell'intestazione APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valore che punta a una matrice di SQLUSMALLINT valori contenente le informazioni di stato per ogni riga di valori di parametro dopo una chiamata a **SQLExecute** oppure **SQLExecDirect**. Questo campo è obbligatorio solo se PARAMSET_SIZE è maggiore di 1.<br /><br /> I valori di stato possono contenere i valori seguenti:<br /><br /> SQL_PARAM_SUCCESS: L'istruzione SQL è stata eseguita correttamente per questo set di parametri.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: L'istruzione SQL è stata eseguita correttamente per questo set di parametri. Tuttavia, le informazioni sull'avviso è disponibile nella struttura di dati di diagnostica.<br /><br /> SQL_PARAM_ERROR: Si è verificato un errore nell'elaborazione di questo set di parametri. Informazioni aggiuntive sull'errore è disponibile nella struttura di dati di diagnostica.<br /><br /> SQL_PARAM_UNUSED: Questo set di parametri è inutilizzato, probabilmente dovuto al fatto che alcuni set di parametri precedente ha causato un errore che ha interrotto l'ulteriore elaborazione o SQL_PARAM_IGNORE è stato impostato per tale set di parametri nella matrice specificata per il SQL_ATTR_PARAM_OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: Il driver considera le matrici di parametri come un'unità monolitica e quindi, non genera questo livello di informazioni sull'errore.<br /><br /> Questo attributo istruzione può essere impostato su un puntatore null, nel quale caso il driver non restituisce parametri valori di stato. Questo attributo può essere impostato in qualsiasi momento, ma il nuovo valore non viene usato fino alla prossima **SQLExecute** oppure **SQLExecDirect** viene chiamato. Si noti che se si imposta questo attributo può influenzare il comportamento di parametro di output implementato dal driver.<br /><br /> Per altre informazioni, vedere [utilizzando le matrici di parametri](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Se si imposta questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_STATUS_PTR nell'intestazione IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|Un SQLULEN \* campi di record che punti a un buffer in cui restituire il numero di set di parametri che sono stati elaborati, compresi i set di errore. Non verrà restituito alcun numero se si tratta di un puntatore null.<br /><br /> Se si imposta questo attributo di istruzione imposta il campo SQL_DESC_ROWS_PROCESSED_PTR nell'intestazione IPD.<br /><br /> Se la chiamata a **SQLExecDirect** oppure **SQLExecute** che compila il buffer a cui fa riferimento questo attributo non viene restituito SQL_SUCCESS o SQL_SUCCESS_WITH_INFO, il contenuto del buffer non è definito.<br /><br /> Per altre informazioni, vedere [utilizzando le matrici di parametri](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|Un valore SQLULEN che specifica il numero di valori per ogni parametro. Se SQL_ATTR_PARAMSET_SIZE è maggiore di 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR del punto APD alle matrici. La cardinalità di ogni matrice è uguale al valore di questo campo.<br /><br /> Questo attributo viene ignorato quando nessun parametro di associazione.<br /><br /> Per altre informazioni, vedere [utilizzando le matrici di parametri](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Se si imposta questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_SIZE nell'intestazione APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1.0)|Un valore SQLULEN corrispondente al numero di secondi di attesa di un'istruzione SQL da eseguire prima di restituire all'applicazione. Se *ValuePtr* è uguale a 0 (impostazione predefinita), non vi è alcun timeout.<br /><br /> Se il timeout specificato supera il timeout massimo nell'origine dati o è inferiore al timeout minimo **SQLSetStmtAttr** sostituisce quel valore e restituisce SQLSTATE 01S02 (valore dell'opzione modificato).<br /><br /> Si noti che l'applicazione non è necessario chiamare **SQLCloseCursor** riutilizzare l'istruzione, se un **seleziona** timeout dell'istruzione.<br /><br /> Timeout query impostato nell'attributo istruzione non valido in modalità sincrona e asincrona.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2.0)|Un valore SQLULEN:<br /><br /> SQL_RD_ON = **SQLFetchScroll** e, in ODBC *3.x*, **SQLFetch** recuperare i dati dopo che il cursore viene posizionato nel percorso specificato. Questa è l'impostazione predefinita.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** e, in ODBC *3.x*, **SQLFetch** non recuperare i dati dopo che posiziona il cursore.<br /><br /> Se si imposta SQL_RETRIEVE_DATA SQL_RD_OFF, un'applicazione può verificare che una riga esiste o recuperare un segnalibro per la riga senza l'overhead di recupero di righe. Per altre informazioni, vedere [scorrimento e recupero di righe](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> Il valore di questo attributo può essere impostato su un cursore aperto. Tuttavia, l'impostazione potrebbe non aver effetto immediato, nel qual caso il driver restituirà 01S02 valore SQLSTATE (valore dell'opzione modificato) e reimpostare l'attributo il valore originale.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Un valore SQLULEN che specifica il numero di righe restituito da ogni chiamata a **SQLFetch** oppure **SQLFetchScroll**. È anche il numero di righe in una matrice di segnalibro utilizzata in un'operazione di segnalibro bulk nelle **SQLBulkOperations**. Il valore predefinito è 1.<br /><br /> Se le dimensioni del set di righe specificato superano la dimensione massima del set di righe supportata dall'origine dati, il driver sostituisce quel valore e restituisce SQLSTATE 01S02 (valore dell'opzione modificato).<br /><br /> Per altre informazioni, vedere [dimensioni del set di righe](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> Se si imposta questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_SIZE nell'intestazione ARD.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|Un SQLULEN * valore cui fa riferimento a un offset aggiunto ai puntatori a modificare l'associazione di dati della colonna. Se questo campo è diverso da null, il driver Dereferenzia il puntatore del mouse, aggiunge il valore dereferenziato a ognuno dei campi posticipati nel record del descrittore (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR) e utilizza i nuovi valori di puntatore durante l'associazione. È impostato su null per impostazione predefinita.<br /><br /> Se si imposta questo attributo di istruzione imposta il campo SQL_DESC_BIND_OFFSET_PTR nell'intestazione ARD.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Un valore SQLULEN che imposta l'orientamento di associazione da utilizzare quando **SQLFetch** oppure **SQLFetchScroll** viene chiamato sull'istruzione associata. L'associazione è selezionata, impostare il valore su SQL_BIND_BY_COLUMN. L'associazione per riga è selezionata, impostando il valore per la lunghezza di una struttura o un'istanza di un buffer in cui verranno associate le colonne di risultati.<br /><br /> Se viene specificata una lunghezza, deve includere lo spazio per tutte le colonne associate ed eventuale riempimento della struttura o del buffer per garantire che quando l'indirizzo di una colonna associata viene incrementato con la lunghezza specificata, il risultato punterà all'inizio della stessa colonna nella posizione riga successiva e. Quando si usa la **sizeof** operatore con strutture o unioni in ANSI C, questo comportamento è garantito.<br /><br /> L'associazione è l'orientamento di associazione predefinito per **SQLFetch** e **SQLFetchScroll**.<br /><br /> Per altre informazioni, vedere [associazione di colonne per l'utilizzo con cursori rettangolari](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> Se si imposta questo attributo di istruzione imposta il campo SQL_DESC_BIND_TYPE nell'intestazione ARD.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2.0)|Imposta un valore SQLULEN che corrisponde al numero della riga corrente nel risultato intero. Se non è possibile determinare il numero di riga corrente o nessuna riga corrente, il driver restituisce 0.<br /><br /> Questo attributo può essere recuperato da una chiamata a **SQLGetStmtAttr** ma non è stato impostato da una chiamata a **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|Un SQLUSMALLINT \* utilizzato per ignorare una riga durante un'operazione bulk con valore che punta a una matrice di valori SQLUSMALLINT **SQLSetPos**. Ogni valore è impostato su SQL_ROW_PROCEED (per la riga da includere nell'operazione di massa) o SQL_ROW_IGNORE (per la riga da escludere dall'operazione di massa). (Righe non possono essere ignorate utilizzando questa matrice durante le chiamate a **SQLBulkOperations**.)<br /><br /> Questo attributo di istruzione può essere impostato a un puntatore null, nel quale caso il driver non restituisce valori di stato di riga. Questo attributo può essere impostato in qualsiasi momento, ma il nuovo valore non viene usato fino alla prossima **SQLSetPos** viene chiamato.<br /><br /> Per altre informazioni, vedere [l'aggiornamento di righe nel set di righe con SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) e [procedura: eliminare righe nel set di righe con SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> Se si imposta questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_STATUS_PTR il ARD.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valore che punta a una matrice di SQLUSMALLINT valori che contengono valori di stato di riga dopo una chiamata a **SQLFetch** oppure **SQLFetchScroll**. La matrice ha tutti gli elementi poiché sono presenti righe nel set di righe.<br /><br /> Questo attributo di istruzione può essere impostato a un puntatore null, nel quale caso il driver non restituisce valori di stato di riga. Questo attributo può essere impostato in qualsiasi momento, ma il nuovo valore non viene usato fino alla prossima **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**, o  **SQLSetPos** viene chiamato.<br /><br /> Per altre informazioni, vedere [numero di righe recuperate e stato](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Se si imposta questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_STATUS_PTR nell'intestazione IRD.<br /><br /> Questo attributo viene eseguito il mapping da un database ODBC *2.x* driver per il *rgbRowStatus* matrice in una chiamata a **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|Un SQLULEN \* valore che fa riferimento a un buffer in cui restituire il numero di righe recuperate dopo una chiamata a **SQLFetch** oppure **SQLFetchScroll**; il numero di righe interessate da un'operazione bulk eseguite da una chiamata a **SQLSetPos** con un *operazione* argomento SQL_REFRESH; o il numero di righe interessate dall'operazione bulk eseguita da **SQLBulkOperations**. Questo numero include le righe di errore.<br /><br /> Per altre informazioni, vedere [numero di righe recuperate e stato](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Se si imposta questo attributo di istruzione imposta il campo SQL_DESC_ROWS_PROCESSED_PTR nell'intestazione IRD.<br /><br /> Se la chiamata a **SQLFetch** oppure **SQLFetchScroll** che compila il buffer a cui fa riferimento questo attributo non viene restituito SQL_SUCCESS o SQL_SUCCESS_WITH_INFO, il contenuto del buffer non è definito.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2.0)|Un valore che specifica se i driver che simulano posizionati istruzioni update e delete di SQLULEN garantisce che tali istruzioni interessano solo una singola riga.<br /><br /> Per simulare l'aggiornamento posizionato ed eliminare le istruzioni, la maggior parte dei driver di costruire un ricercata **aggiornare** o **eliminare** istruzione contenente un **dove** clausola che specifica il valore di ogni colonna nella riga corrente. A meno che queste colonne costituiscono una chiave univoca, tale istruzione può influire sulle più di una riga.<br /><br /> Per garantire che tali istruzioni interessano solo una riga, il driver determina le colonne in una chiave univoca e aggiunge queste colonne in set di risultati. Se un'applicazione garantisce che le colonne nel set di risultati costituiscono una chiave univoca, il driver non è necessario eseguire questa operazione. Questo potrebbe ridurre il tempo di esecuzione.<br /><br /> SQL_SC_NON_UNIQUE = il driver non garantisce che la simulazione posizionato update o istruzioni di eliminazione influirà solo una riga. è responsabilità dell'applicazione per eseguire questa operazione. Se un'istruzione interessa più righe, **SQLExecute**, **SQLExecDirect**, o **SQLSetPos** restituisce SQLSTATE 01001 (conflitto dell'operazione del cursore).<br /><br /> SQL_SC_TRY_UNIQUE = il driver tenta di garantire che ha simulato posizionato aggiornamento o eliminazione di istruzioni interessano solo una riga. Il driver esegue always tali istruzioni, anche se che potrebbero influire su più righe, ad esempio quando è presente alcuna chiave univoca. Se un'istruzione interessa più righe, **SQLExecute**, **SQLExecDirect**, o **SQLSetPos** restituisce SQLSTATE 01001 (conflitto dell'operazione del cursore).<br /><br /> SQL_SC_UNIQUE = le garanzie di driver simulati per gli aggiornamenti posizionati o eliminare le istruzioni interessano solo una riga. Se il driver non può garantire per una determinata istruzione **SQLExecDirect** oppure **SQLPrepare** restituisce un errore.<br /><br /> Se l'origine dati fornisce SQL nativo il supporto per aggiornamento posizionato ed eliminare le istruzioni e il driver non simulare i cursori, viene restituito SQL_SUCCESS quando viene richiesto SQL_SC_UNIQUE per SQL_SIMULATE_CURSOR. Se viene richiesto SQL_SC_TRY_UNIQUE o SQL_SC_NON_UNIQUE, viene restituito SQL_SUCCESS_WITH_INFO. Se l'origine dati fornisce il livello SQL_SC_TRY_UNIQUE di supporto e il driver non esiste, viene restituito SQL_SUCCESS per SQL_SC_NON_UNIQUE viene restituito SQL_SUCCESS_WITH_INFO e SQL_SC_TRY_UNIQUE.<br /><br /> Se il tipo di simulazione di cursore specificato non è supportato dall'origine dati, il driver sostituisce un tipo diverso di simulazione e restituisce SQLSTATE 01S02 (valore dell'opzione modificato). Per SQL_SC_UNIQUE, il driver sostituisce, in ordine, SQL_SC_TRY_UNIQUE o SQL_SC_NON_UNIQUE. Per SQL_SC_TRY_UNIQUE, il driver sostituisce SQL_SC_NON_UNIQUE.<br /><br /> Il valore predefinito è SQL_SC_UNIQUE.<br /><br /> Per altre informazioni, vedere [simulando posizionato istruzioni Update e Delete](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2.0)|Un valore SQLULEN che specifica se un'applicazione utilizzerà i segnalibri con un cursore:<br /><br /> SQL_UB_OFF = Off (impostazione predefinita)<br /><br /> SQL_UB_VARIABLE = segnalibri verranno usate dall'applicazione con un cursore e il driver fornirà a lunghezza variabile segnalibri se sono supportate. In ODBC è deprecata SQL_UB_FIXED *3.x*. ODBC *3.x* le applicazioni devono utilizzare sempre a lunghezza variabile segnalibri, anche quando si lavora con ODBC *2.x* driver (che è supportata solo a 4 byte e a lunghezza fissa segnalibri). Questo avviene perché un segnalibro a lunghezza fissa è semplicemente un caso speciale di un segnalibro a lunghezza variabile. Quando si lavora con un database ODBC *2.x* driver, Driver Manager esegue il mapping SQL_UB_VARIABLE a SQL_UB_FIXED.<br /><br /> Per usare i segnalibri con un cursore, l'applicazione è necessario specificare questo attributo con il valore SQL_UB_VARIABLE prima dell'apertura del cursore.<br /><br /> Per altre informazioni, vedere [recupero di segnalibri](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] queste funzioni possono essere chiamate in modo asincrono solo se il descrittore è un descrittore di implementazione, non un descrittore dell'applicazione.  
  
 Visualizzare [associazione per colonna](../../../odbc/reference/develop-app/column-wise-binding.md) e [l'associazione per riga](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Funzioni correlate  
  
|Per informazioni su|Vedere|  
|---------------------------|---------|  
|Annullare l'elaborazione di istruzione|[Funzione SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Restituisce l'impostazione di un attributo di connessione|[Funzione SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Restituisce l'impostazione di un attributo di istruzione|[Funzione SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Impostare un attributo di connessione|[Funzione SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Impostazione di un singolo campo del descrittore|[Funzione SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Vedere anche  
 [Riferimento all'API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [File di intestazione ODBC](../../../odbc/reference/install/odbc-header-files.md)
